---
// This component only contains JavaScript for timeline tracking
---

<script>
	const ACTIVE_CARD_SCALE_CLASS = 'scale-103';
	const ACTIVE_CARD_SHADOW_CLASS = 'shadow-lg';

	const DEFAULT_TIMELINE_MARKER_BG_CLASSES = ['bg-gray-400', 'dark:bg-gray-500'];
	const ACTIVE_JOB_TIMELINE_MARKER_BG_CLASSES = ['bg-blue-500', 'dark:bg-blue-400'];
	const ACTIVE_PROJECT_TIMELINE_MARKER_BG_CLASSES = ['bg-purple-500', 'dark:bg-purple-400'];

	const DEFAULT_TIMELINE_LABEL_TEXT_CLASSES = ['text-gray-400', 'dark:text-gray-500'];
	const ACTIVE_TIMELINE_LABEL_TEXT_CLASSES = ['text-gray-900', 'dark:text-gray-100'];

	interface TimelineCardElement {
		el: HTMLElement;
		index: number;
		anchor: string;
		rect: {
			elTopToPageTop: number;
			elBottomToPageTop: number;
			elHeight: number;
		}
	}

	interface TimelineProgressBarItem {
		el: HTMLElement;
		index: number;
		anchor: string;
	}

	type TimelineCardState = 'past' | 'upcoming' | 'showing' | 'active';
	type ViewportLineRelation = 'above' | 'below';
	type ViewportFrameRelation = 'fully-above' | 'fully-below' | 'partially-above' | 'partially-below' | 'contained';

	interface CardEdgeRelationships {
		viewportBottom: ViewportLineRelation;
		viewportCenter: ViewportLineRelation;
		viewportTop: ViewportLineRelation;
	}

	interface TimelineCard {
		card: TimelineCardElement;
		state: TimelineCardState;
		cardTop: CardEdgeRelationships;
		cardBottom: CardEdgeRelationships;
		cardBody: ViewportFrameRelation;
	}

	interface WindowPositionState {
		height: number;
		scrollY: number;
		windowTop: number;
		windowBottom: number;
		windowCenter: number;
	}

	function getWindowPositionState(): WindowPositionState {
		const height = window.innerHeight
		const scrollY = document.documentElement.scrollTop

		const windowTop = scrollY
		const windowBottom = scrollY + height
		const windowCenter = scrollY + height / 2
		
		return {
			height, scrollY, windowTop, windowBottom, windowCenter
		};
	}

	function getTimelineCardElements(): TimelineCardElement[] {
		return [...document.querySelectorAll('.timeline-tracker-card')]
			.map((card, index) => {
				const el = card as HTMLElement;
				const anchor = el.dataset.timelineAnchor || "none";
				const elRect = el.getBoundingClientRect();

				const rect = { 
					elTopToPageTop: elRect.top + window.scrollY,
					elBottomToPageTop: elRect.bottom + window.scrollY,
					elHeight: elRect.height
				}
			
				return { el, index, anchor, rect }
		})
	}

	function getProgressBarItems(): TimelineProgressBarItem[] {
		let elems = [...document.querySelectorAll('.timeline-item')];

		return elems.map((item, index) => {
			const el = item as HTMLElement;
			const anchor = el.dataset.timelineAnchor || 'none';
			
			return { el, index, anchor } as TimelineProgressBarItem;
		})
	}

	function getTimelineCard(card: TimelineCardElement, windowPosition: WindowPositionState): TimelineCard {
		const { rect } = card;

		const cardBottomPosition = rect.elBottomToPageTop;
		const cardTopPosition = rect.elTopToPageTop;
		const windowBottom = windowPosition.windowBottom;
		const windowTop = windowPosition.windowTop;
		const windowCenter = windowPosition.windowCenter;

		const cardTop: CardEdgeRelationships = {
			viewportBottom: cardTopPosition < windowTop ? 'above' : 'below',
			viewportCenter: cardTopPosition < windowCenter ? 'above' : 'below',
			viewportTop: cardTopPosition > windowBottom ? 'above' : 'below'
		}

		const cardBottom: CardEdgeRelationships = {
			viewportBottom: cardBottomPosition > windowBottom ? 'below' : 'above',
			viewportCenter: cardBottomPosition > windowCenter ? 'below' : 'above',
			viewportTop: cardBottomPosition < windowTop ? 'below' : 'above'
		}

		const isInViewport = cardTopPosition >= windowTop && cardBottomPosition <= windowBottom;
    const isAboveViewport = cardTopPosition < windowTop;

		const cardBody: ViewportFrameRelation = isInViewport ? 'contained' : isAboveViewport ? 'fully-above' : 'fully-below';
		
		// We make what determinations we can here, but the final state is determined by comparing to other cards
		let state: TimelineCardState = 'showing';
		
		// If the card is above the viewport, it is past
		if (cardBottom.viewportBottom === 'above') {
			state = 'past';
		}
		
		// If the card is below the viewport, it is next
		if (cardTop.viewportBottom === 'below') {
			state = 'upcoming';
		}
		
		return {
			card, state, cardTop, cardBottom, cardBody
		};
	}

	// Timeline scroll tracking
	function updateTimelineProgress() {
		const windowPosition: WindowPositionState = getWindowPositionState();
		const cardElements: TimelineCardElement[] = getTimelineCardElements();
		const cards: TimelineCard[] = cardElements.map((cardEl) => getTimelineCard(cardEl, windowPosition));

		// Past cards (cards that are above the viewport) have active timeline markers and
		// labels, but are not the active card
		const pastCards = cards.filter((card) => card.state === 'past');
		
		// Showing cards are fully in the viewport. For large viewports this could be multiple 
		// cards; for small viewports this might not be any cards. 
		const showingCards = cards.filter((card) => card.state === 'showing');
		
		// There will be only one active card. Initially, the first card is active.
		let activeCard: TimelineCard = cards[0]

		// Here is the more complex approach to the active card:
		// 1. If t=here is a single "showing" card, that is the active card
		// 2. If there are multiple "showing" cards, the first one is the active card.
		// 3. If there are no "showing" cards, the last card to break the center line is the active card.

		// If there is a single "showing" card, that is the active card
		if (showingCards.length === 1) {
			activeCard = showingCards[0];
		}
		
		// If there are multiple "showing" cards, the first one is the active card
		if (showingCards.length > 1) {
			activeCard = showingCards[0];
		}

		// If there are no "showing" cards, the last card to break the center line is the active card
		if (showingCards.length === 0) {
			activeCard = cards.findLast((card) => card.cardTop.viewportCenter === 'above') || cards[0];
		}

		activeCard.state = 'active';

		const activeCardIndex = activeCard.card.index;

		// Update the #timeline-progress element's height
		const progressElement: HTMLElement | null = document.getElementById('timeline-progress');

		if (progressElement) {
			progressElement.style.height = `${activeCardIndex / (cards.length - 1) * 100}%`;
		}

		cards.forEach((card) => {
			if (card.state === 'active') {
				card.card.el.classList.add(ACTIVE_CARD_SCALE_CLASS);
				card.card.el.classList.add(ACTIVE_CARD_SHADOW_CLASS);
			} else {
				card.card.el.classList.remove(ACTIVE_CARD_SCALE_CLASS);
				card.card.el.classList.remove(ACTIVE_CARD_SHADOW_CLASS);
			}

			const progressBarItems = [...document.querySelectorAll('.timeline-item')];
			
			progressBarItems.forEach(item => {
				const el = item as HTMLElement;
				const anchor = el.dataset.timelineAnchor

				const marker = el.querySelector('.timeline-marker') as HTMLElement;
				const label = el.querySelector('.timeline-label-text') as HTMLElement;

				const cardType: string = el.dataset.timelineType || 'employment';
				const itemIsActiveItem = anchor === activeCard.card.anchor
				const itemIsPastItem = pastCards.some((card) => card.card.anchor === anchor);

				if (itemIsActiveItem || itemIsPastItem) {
					if (cardType === 'employment') {
						marker.classList.remove(...DEFAULT_TIMELINE_MARKER_BG_CLASSES);
						marker.classList.add(...ACTIVE_JOB_TIMELINE_MARKER_BG_CLASSES);
					}

					if (cardType === 'project') {
						marker.classList.remove(...DEFAULT_TIMELINE_MARKER_BG_CLASSES);
						marker.classList.add(...ACTIVE_PROJECT_TIMELINE_MARKER_BG_CLASSES);
					}
					
				} else {
					marker.classList.remove(...ACTIVE_JOB_TIMELINE_MARKER_BG_CLASSES, ...ACTIVE_PROJECT_TIMELINE_MARKER_BG_CLASSES);
					marker.classList.add(...DEFAULT_TIMELINE_MARKER_BG_CLASSES);
				}

				// Active item text is dark, past item text is light
				if (itemIsActiveItem) {
					label.classList.remove(...DEFAULT_TIMELINE_LABEL_TEXT_CLASSES);
					label.classList.add(...ACTIVE_TIMELINE_LABEL_TEXT_CLASSES);
				} else {
					label.classList.remove(...ACTIVE_TIMELINE_LABEL_TEXT_CLASSES);
					label.classList.add(...DEFAULT_TIMELINE_LABEL_TEXT_CLASSES);
				}
			});
		})
	}

	function onContentLoaded() {
		const progressItems = getProgressBarItems();

		
		
		progressItems.forEach(item => {
			item.el.addEventListener('click', () => {
				const cards = getTimelineCardElements();
				const card = cards.find(card => card.anchor == item.anchor)

				if (card) {
					const siteHeader = document.getElementById('site-header');
					let headerOffset = 0;

					if (siteHeader) {	
						headerOffset = siteHeader.clientHeight;
					}

					const cardTop = card.el.getBoundingClientRect().top;
					const scrollTo = cardTop + window.pageYOffset - headerOffset - 20;

					window.scrollTo({ top: scrollTo, behavior: 'smooth' });
				}
			});
		});
	}
	
	// Throttle function for performance
	function throttle(func: Function, limit: number) {
		let inThrottle: boolean = false;
		return function(this: Window, ...args: any[]) {
			if (!inThrottle) {
				func.apply(this, args);
				inThrottle = true;
				setTimeout(() => inThrottle = false, limit);
			}
		}
	}
	
	// Add scroll event listener
	window.addEventListener('scroll', throttle(updateTimelineProgress, 16));
	
	// Initial call
	document.addEventListener('DOMContentLoaded', updateTimelineProgress);
	document.addEventListener('DOMContentLoaded', onContentLoaded);
</script> 