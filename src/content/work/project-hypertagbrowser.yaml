type: "project"

projectName: "HyperTagBrowser"
title: "macOS File Browser with Advanced Tagging System"

startDate: "2024-09"
current: true

githubUrl: "https://github.com/robinsr/hyper-tag-browser"

description: >
  A sophisticated macOS file browser application built with SwiftUI that provides advanced file organization 
  through a comprehensive tagging system. The app features intelligent file indexing, metadata management, and 
  powerful search capabilities, allowing users to organize and discover files through descriptive tags, attribution 
  metadata, and custom work queues.


highlights:
  - Built a native macOS application using SwiftUI and AppKit with a modern, responsive interface featuring grid and table views for file browsing
  - Implemented a sophisticated tagging system with multiple domains including descriptive tags, attributionmetadata (artist, creator, owner), creation dates, and work queues
  - Developed a robust file indexing service using GRDB (SQLite) for persistent storage of file metadata, tags, and relationships
  - Created an intelligent file identification system using extended attributes to maintain unique content IDs across file operations
  - Integrated macOS system services including QuickLook for thumbnail generation, Spotlight for search, and file system monitoring for real-time updates
  - Built a comprehensive search system supporting complex queries with tag-based filtering, date ranges, and full-text search capabilities
  - Implemented a work queue system for batch operations and task management with visual progress tracking
  - Designed a modular architecture with dependency injection using Factory framework for maintainable and testable code
  - Added advanced features including drag-and-drop support, keyboard navigation, context menus, and customizable UI panels
  - Integrated with macOS system features like clipboard operations, file operations (rename, move, trash), and volume management

technologies:
  
  # Programming Languages

  - name: Java
    type: language_tech
    description: Primary backend language for developing services and APIs that powered global merchandising tools. Used extensively to build scalable, asynchronous systems with strong reliability and observability.

  - name: JavaScript
    type: language_tech
    description: Used across the stack for building asynchronous UI behavior and contributing to internal tooling. Supported service debugging workflows and browser-based tools.

  - name: TypeScript
    type: language_tech
    description: Used to modernize frontend tooling and increase type safety in JavaScript applications. Helped reduce runtime errors and improve maintainability.

  - name: HTML
    type: language_tech
    description: Developed accessible, semantic markup to support dynamic content and interactive merchandising features.

  - name: CSS
    type: language_tech
    description: Styled responsive and accessible UIs within merchandising tools, using modular design practices.

  # Frameworks & Tools

  - name: Apache Spark
    type: framework_tooling
    description: Built data pipelines with Apache Spark to extract and aggregate merchandising metrics, improving visibility into campaign performance and customer behavior.

  # Cloud Services and Platforms

  - name: AWS
    type: infra_platform
    description: Migrated legacy infrastructure to AWS-native services to improve scalability, reduce operational overhead, and align with modern best practices in cloud architecture.

  - name: Lambda
    type: infra_platform
    description: Used AWS Lambda for lightweight, event-driven workflows that augmented core service functionality and simplified integration with internal tooling.

  - name: S3
    type: infra_platform
    description: Leveraged Amazon S3 for durable storage of campaign assets and service artifacts in support of global merchandising operations.

  - name: CloudFormation
    type: infra_platform
    description: Used AWS CloudFormation to define and manage infrastructure as code, enabling reproducible and auditable deployments across environments.

  - name: IAM
    type: infra_platform
    description: Managed fine-grained permissions using AWS IAM to secure access between services, Lambda functions, and developer tools, with a focus on least privilege.

  # Engineering Practices

  - name: CI/CD
    type: engineering_practice
    description: Established CI/CD pipelines with automated testing and linting to enable safe, frequent deployments to production with minimal manual overhead.

  - name: Observability
    type: engineering_practice
    description: Improved system visibility by integrating metrics, structured logging, and dashboards for key service performance indicators.

  - name: Error Tracking
    type: engineering_practice
    description: Instrumented production services with tooling to surface high-severity errors, reducing time to resolution during incidents.

  - name: Accessibility (a11y)
    type: engineering_practice
    description: Applied accessibility best practices in markup and interaction design to meet Amazon's internal a11y standards and improve customer experience.

  - name: UX Collaboration
    type: engineering_practice
    description: Partnered closely with UX designers to iterate on dynamic interfaces and improve usability of internal tools and customer-facing features.

  - name: Data Quality
    type: engineering_practice
    description: Closed gaps in campaign metrics through the introduction of new data pipelines and validation tooling.

  - name: Service Modernization
    type: engineering_practice
    description: Led efforts to refactor and migrate legacy services to AWS-native architectures and event-driven patterns.

  - name: Metrics Instrumentation
    type: engineering_practice
    description: Integrated detailed performance metrics into production services to track availability, latency, and error rates in real time.

  - name: Developer Experience
    type: engineering_practice
    description: Delivered internal tooling and debug features to support faster iteration, root cause analysis, and production readiness for partner teams.

  # Architecture Patterns

  - name: RESTful APIs
    type: architecture_pattern
    description: Designed and maintained REST APIs supporting asynchronous frontend interactions and integrations with partner teams across Amazon retail.

  - name: Distributed Systems
    type: architecture_pattern
    description: Built and maintained high-reliability distributed services, with a focus on performance, consistency, and graceful degradation under load.

  # System Capabilities

  - name: Campaign Management
    type: system_capability
    description: Built backend services to support the scheduling, targeting, and delivery of merchandising campaigns across global retail platforms.

  # Delivery Context

  - name: Internal Tools
    type: delivery_context
    description: Built browser-based developer tooling to aid debugging of merchandising services and improve operational efficiency for partner teams.


images:
  base_url: "https://raw.githubusercontent.com/robinsr/hyper-tag-browser/main/screenshots"
  # base_url: "./tmp-hypertag-screenshots/screenshots"
  
  primary:
    full: "010-hypertagbrowser-browse-main.png"
    thumbnail: "thumbs/010-hypertagbrowser-browse-main.png"
    alt: "HyperTagBrowser Browse Screen"
  
  showcase:
    
    - full: "010-hypertagbrowser-browse-main.png"
      thumbnail: "thumbs/010-hypertagbrowser-browse-main.png"
      alt: >
        1. The file browser is relatively intuitive, mirroring the Finder's layout and behavior.

    - full: "011-hypertagbrowser-browse-cursor-single.png"
      thumbnail: "thumbs/011-hypertagbrowser-browse-cursor-single.png"
      alt: >
        2. Item selection using mouse or keyboard navigation

    - full: "012-hypertagbrowser-browse-cursor-multi-item.png"
      thumbnail: "thumbs/012-hypertagbrowser-browse-cursor-multi-item.png"
      alt: >
        3. Multi-item selection supported using mouse or shift + arrow keys

    - full: "013-hypertagbrowser-browse-refinements.png"
      thumbnail: "thumbs/013-hypertagbrowser-browse-refinements.png"
      alt: >
        4. ⌃+F opens the Refinements panel, which can be used to filter the file browser by tag, date, and more.

    - full: "014-hypertagbrowser-browse-refinements-applied.png"
      thumbnail: "thumbs/014-hypertagbrowser-browse-refinements-applied.png"
      alt: >
        5. Refinements can be applied to the file browser, including filtering by tag, date, and more.

    - full: "015-hypertagbrowser-browser-refine-not-filter.png"
      thumbnail: "thumbs/015-hypertagbrowser-browser-refine-not-filter.png"
      alt: >
        6. Individual refinements can be toggled as inclusive or exclusive.

    - full: "016-hypertagbrowser-stashed-tags.png"
      thumbnail: "thumbs/016-hypertagbrowser-stashed-tags.png"
      alt: >
        7. The Tag Stash panel can be used to build sets of tags to be applied simultaneously to multiple items.

    - full: "020-hypertagbrowser-search-sheet-main.png"
      thumbnail: "thumbs/020-hypertagbrowser-search-sheet-main.png"
      alt: >
        8. The Search Sheet has more free-form search capabilities, with a simple DSL for building complex queries
        across tags, dates, creators, and filenames.

    - full: "030-hypertagbrowser-browse-tag-sheet-search.png"
      thumbnail: "thumbs/030-hypertagbrowser-browse-tag-sheet-search.png"
      alt: >
        9. ⌘+T displays the 'Tag Sheet' for an item, presenting a UI for managing item tag associations
        including a search field for finding existing tags and a keyboard-scrollable list of the 
        current tag associations. Pressing ↵ toggles a tag association, allowing users to construct
        the set of tags for an item or items, with changes only being applied when the user exits the sheet.

    - full: "030-hypertagbrowser-browse-tag-sheet-multi-item.png"
      thumbnail: "thumbs/030-hypertagbrowser-browse-tag-sheet-multi-item.png"
      alt: >
        10. The Tag Sheet supports editing associations for multiple items at once. Only common tag associations
        are shown, and any edits to the tag associations are applied to all selected items. Item's unique
        tags (omitted from the Tag Sheet) are preserved.

    - full: "040-hypertagbrowser-detail-main-dark.png"
      thumbnail: "thumbs/040-hypertagbrowser-detail-main-dark.png"
      alt: >
        11. The item detail screen shows the item's metadata, including tags, dates, and more.

    # Composite light/dark mode image missing transparency - cant figure out the right imagemagick command to make it work
    # - full: "040-hypertagbrowser-detail-main-diagonal.png"
    #   thumbnail: "thumbs/040-hypertagbrowser-detail-main-diagonal.png"
    #   alt: >
    #     tbd — 040-hypertagbrowser-detail-main-diagonal.png

    - full: "040-hypertagbrowser-detail-main-light.png"
      thumbnail: "thumbs/040-hypertagbrowser-detail-main-light.png"
      alt: >
        12. HyperTagBrowser supports dark and light mode.

    - full: "040-hypertagbrowser-details-file-rename.png"
      thumbnail: "thumbs/040-hypertagbrowser-details-file-rename.png"
      alt: >
        13. The item detail screen supports renaming the item.

    - full: "040-hypertagbrowser-details-inspector-2.png"
      thumbnail: "thumbs/040-hypertagbrowser-details-inspector-2.png"
      alt: >
        14. The item detail screen supports a variety of actions, including renaming, moving, and deleting the item.

    - full: "040-hypertagbrowser-details-tag-context-menu-recategorize.png"
      thumbnail: "thumbs/040-hypertagbrowser-details-tag-context-menu-recategorize.png"
      alt: >
        15. The item detail screen supports recategorizing a tag association, essentially changing the the meaning
        of the tag association (eg, a keyword association, a creator association, etc.)

    - full: "040-hypertagbrowser-details-tag-context-menu.png"
      thumbnail: "thumbs/040-hypertagbrowser-details-tag-context-menu.png"
      alt: >
        16. Various actions on a tag or tag association can be performed from the context menu.

    - full: "040-hypertagbrowser-details-tag-sheet.png"
      thumbnail: "thumbs/040-hypertagbrowser-details-tag-sheet.png"
      alt: >
        17. The Tag Sheet is also accessible from the item detail screen.

    - full: "080-hypertagbrowser-settings-general.png"
      thumbnail: "thumbs/080-hypertagbrowser-settings-general.png"
      alt: >
        18. The Settings screen showing some general user preferences.

    - full: "081-hypertagbrowser-settings-appearance.png"
      thumbnail: "thumbs/081-hypertagbrowser-settings-appearance.png"
      alt: >
        19. The Settings screen supports changing the app's appearance.

    - full: "090-hypertagbrowser-key-shortcuts.png"
      thumbnail: "thumbs/090-hypertagbrowser-key-shortcuts.png"
      alt: >
        20. A help screen showing the keyboard shortcuts.


draft_reflections: >
  This project started as an exploration of macOS development and quickly grew into a deep dive 
  into file systems, metadata indexing, and native app architecture. I wanted to build a power-user 
  tool that felt truly native—fast, keyboard-driven, and tightly integrated with macOS. The tagging 
  system evolved out of my own frustration with Finder’s limitations, and implementing extended 
  attributes and persistent content IDs was both technically challenging and satisfying.

  One of the most eye-opening aspects of the project was working directly with a local database. 
  In most modern web services and frontend apps, you rarely touch the data layer directly—you’re 
  calling APIs or operating on abstractions. Here, I used GRDB with SQLite to build a custom schema 
  from scratch, and was surprised at how few options exist for serious native app data storage: 
  Core Data, SwiftData, or hand-rolled SQLite. Schema evolution turned out to be particularly tricky— 
  especially when preserving existing user data across updates. I had to get creative around workarounds 
  for limitations like SQLite’s inability to alter certain constraints post-creation, which gave me a 
  deeper respect for the stability and migration tooling we take for granted in other ecosystems.

  This project pushed me to think more like a product engineer than just a developer: What would make 
  this genuinely useful? How should tagging feel? How should batch operations work without being overwhelming? 
  I also got to sharpen my understanding of SwiftUI and dependency injection patterns, and I’m proud of how 
  the app turned out—it feels like something I’d want to use every day. I plan to keep refining it and may 
  eventually extend it to sync or export features across devices.